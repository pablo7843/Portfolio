---
// src/components/InteractiveShell.astro
// Componente de Terminal Interactiva
---
<div id="terminal-wrapper">
    <h2> Terminal -- (Type 'help' to begin)</h2>
    <div id="output-area">
        <p class="prompt-line">
            <span class="prompt-user" id="prompt-user-line">guest@pablo-sec:~$</span> 
            <span id="initial-message">Welcome to Pablo's Portfolio System.</span>
        </p>
    </div>

    <div class="input-line">
        <span class="prompt-user" id="current-prompt-display">guest@pablo-sec:~$</span> 
        <input type="text" id="command-input" autofocus autocomplete="off" />
    </div>
</div>

<style>
    #terminal-wrapper {
        font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        background-color: #0c0c1a;
        color: #00ff00;
        /*  AADIDO: Resplandor sutil al texto para efecto ne贸n/CRT */
        text-shadow: 0 0 5px rgba(0, 255, 0, 0.4); 
        border: 2px solid #00ff00;
        box-shadow: 0 0 15px rgba(0, 255, 0, 0.5);
        padding: 20px;
        margin: 40px auto;
        width: 90%;
        max-width: 800px;
        height: 400px;
        overflow-y: auto;
        user-select: text; 
        cursor: text;
        /*  AADIDO: Transici贸n suave para el scroll */
        scroll-behavior: smooth; 
    }
    h2 {
        user-select: none;
    }
    .prompt-user {
        color: #66ccff; 
        user-select: none; 
        /*  AADIDO: Resplandor al usuario */
        text-shadow: 0 0 5px rgba(102, 204, 255, 0.4);
    }
    #prompt-user-line{
        color: #66ccff;
        user-select: none;
    }
    .input-line {
        display: flex;
        gap: 5px;
        margin-top: 10px;
    }
    #command-input {
        flex-grow: 1;
        background: none;
        border: none;
        color: #00ff00; 
        outline: none;
        caret-color: #00ff00;
        font-family: inherit;
        font-size: inherit;
        user-select: text; 
        /*  AADIDO: Mismo resplandor para el input */
        text-shadow: 0 0 5px rgba(0, 255, 0, 0.4);
    }
    #output-area p {
        margin: 0;
        white-space: pre-wrap;
    }
    #initial-message {
        color: #cccccc;
    }
    
    /*  AADIDO: Clases para dar color espec铆fico a las salidas */
    .color-error { color: #ff3333; text-shadow: 0 0 5px rgba(255, 51, 51, 0.4); }
    .color-info { color: #ffff66; text-shadow: 0 0 5px rgba(255, 255, 102, 0.4); }
</style>

<script>
// @ts-nocheck 

    document.addEventListener('DOMContentLoaded', () => {

        const input = document.getElementById('command-input');
        const output = document.getElementById('output-area');
        const terminalWrapper = document.getElementById('terminal-wrapper');
        const currentPromptDisplay = document.getElementById('current-prompt-display'); 

        if (!input || !output || !terminalWrapper || !currentPromptDisplay) return;

        /** @type {string[]} */
        let history = [];
        let historyIndex = -1;
        let isTyping = false; //  AADIDO: Control de estado para la animaci贸n de escritura

        const fileSystem = {
            "~": {
                "README.txt": "Hello! I'm Pablo, a Cybersecurity Dev. In this portfolio, Im giving you a small overview of my knowledge as a web developer, mobile developer, and cybersecurity technician! See you soon!",
                "projects": {
                    "QR-Shield.txt": "A secure QR code scanner app to prevent phishing. It scans QR codes and checks URLs to decide if the QR code is safe, suspicious or dangerous. User can Sign in to activate the history of scans and manage them.",
                    "HarmoniQ.txt": "Online music player. The user will be able to create playlists, listen music and follow the song with the lyrics of the chosed song.",
                    "Star-WikiWars.txt": "Star Wars wiki on mobile. You will see the especifications of your favourite characters in the movies saga with the possibilities to add your favourite characters to a local Database!",
                },
                "contact": {
                    "email.txt": "pablosanfelix8@gmail.com",
                    "linkedin.txt": "https://www.linkedin.com/in/pablo-climent-sanf茅lix-1b5a77385/"
                }
            },
            currentDir: "~"
        };
        
        //  AADIDO: Nuevos comandos a la lista de autocompletado
        const availableCommands = ['help', 'ls', 'cd', 'cat', 'clear', 'scroll', 'whoami', 'date', 'sudo'];

        const getCurrentDirectoryContent = () => {
            return fileSystem.currentDir === "~"
                ? fileSystem["~"]
                : fileSystem["~"][fileSystem.currentDir];
        };

        const getCompletions = (inputBuffer) => {
            const parts = inputBuffer.trim().split(/\s+/);
            let currentWord = parts.length > 1 ? parts.at(-1) : parts[0];
            const command = parts[0];

            if (parts.length <= 1) {
                const matches = availableCommands.filter(cmd => cmd.startsWith(currentWord));
                if (matches.length === 1) {
                    return { completion: matches[0], matches: [matches[0]] };
                }
                return { completion: currentWord, matches: matches };
            }

            if (command === 'cd' || command === 'cat') {
                const currentContent = getCurrentDirectoryContent();
                if (!currentContent) return { completion: currentWord, matches: [] };
                
                const validTargets = Object.keys(currentContent).filter(name => {
                    const isDirectory = typeof currentContent[name] === 'object';
                    return command === 'cd' ? isDirectory : true; 
                });

                const matches = validTargets.filter(target => target.startsWith(currentWord));

                if (matches.length === 1) {
                    let completion = matches[0];
                    if (command === 'cd' && typeof currentContent[completion] === 'object') {
                        // Nada
                    } else if (command === 'cat') {
                        completion += ' '; 
                    }

                    const completedBuffer = inputBuffer.substring(0, inputBuffer.lastIndexOf(currentWord)) + completion;
                    return { completion: completedBuffer, matches: [matches[0]] };
                }

                return { completion: currentWord, matches: matches };
            }
            
            return { completion: currentWord, matches: [] };
        };

        const updateInputPrompt = () => {
            const path = fileSystem.currentDir === "~" ? "~" : fileSystem.currentDir;
            currentPromptDisplay.textContent = `guest@pablo-sec:${path}$`;
        };

        const executeCommand = (command) => {
            const parts = command.trim().split(/\s+/);
            const cmd = parts[0];
            const args = parts.slice(1);

            switch (cmd) {
                case 'help':
                    return `Available commands: 
                        - help
                        - ls
                        - cd
                        - cat
                        - clear
                        - whoami
                        - date
                        - sudo`;

                //  AADIDO: Nuevos comandos para darle personalidad
                case 'whoami':
                    return { text: "guest\n(But we both know you are a recruiter looking for a great dev)", class: "color-info" };
                
                case 'date':
                    return new Date().toString();

                case 'sudo':
                    return { text: "user is not in the sudoers file. This incident will be reported. ", class: "color-error" };

                case 'ls': {
                    const currentObj = getCurrentDirectoryContent();
                    if (typeof currentObj === "object") {
                        //  MEJORA: A帽adir una marca visual para diferenciar carpetas de archivos
                        return Object.keys(currentObj).map(key => {
                            return typeof currentObj[key] === 'object' ? `[DIR] ${key}` : key;
                        }).join("    ");
                    }
                    return { text: "Error: Cannot list contents of a file.", class: "color-error" };
                }

                case 'cd': {
                    const target = args[0];

                    if (target === ".." || !target || target === "~") {
                        fileSystem.currentDir = "~";
                        updateInputPrompt(); 
                        return "Changed directory to ~";
                    }

                    const obj = fileSystem["~"][target];
                    if (obj && typeof obj === "object") {
                        fileSystem.currentDir = target;
                        updateInputPrompt(); 
                        return `Changed directory to ${target}`;
                    }

                    return { text: `Error: cd: ${target}: No such directory.`, class: "color-error" };
                }

                case 'cat': {
                    const fileName = args[0];
                    if (!fileName) return { text: "Error: cat requires a file name.", class: "color-error" };

                    const currentObj = getCurrentDirectoryContent();

                    if (currentObj && typeof currentObj === "object" && fileName in currentObj) {
                        const content = currentObj[fileName];

                        if (fileName.endsWith(".link")) {
                            return `Opening link: ${content}`;
                        }
                        //  MEJORA: Devolver un objeto especial para que appendOutput sepa que debe animarlo
                        return { text: content, animate: true }; 
                    }
                    return { text: `Error: cat: ${fileName}: No such file.`, class: "color-error" };
                }

                case 'clear':
                    output.innerHTML = "";
                    return "Terminal cleared.";

                default:
                    return { text: `Error: Command not found: ${cmd}`, class: "color-error" };
            }
        };

        //  AADIDO: Funci贸n para simular el tecleo (efecto m谩quina de escribir)
        const typeWriterEffect = (element, text, speed = 10) => {
            isTyping = true;
            input.disabled = true; // Deshabilita input mientras escribe
            let i = 0;
            element.textContent = "";
            
            function type() {
                if (i < text.length) {
                    element.textContent += text.charAt(i);
                    i++;
                    output.scrollTop = output.scrollHeight;
                    setTimeout(type, speed);
                } else {
                    isTyping = false;
                    input.disabled = false;
                    input.focus();
                }
            }
            type();
        };

        const appendOutput = (command, result) => {
            const line = document.createElement("p");
            line.className = "prompt-line";

            const path = fileSystem.currentDir === "~" ? "~" : fileSystem.currentDir;
            
            line.innerHTML = `<span class="prompt-user">guest@pablo-sec:${path}$</span> ${command}`; 
            output.appendChild(line);

            // Manejar si el resultado es un string normal o un objeto con opciones (clases, animaciones)
            let resultText = typeof result === 'string' ? result : result.text;
            let resultClass = typeof result === 'object' && result.class ? result.class : "";
            let shouldAnimate = typeof result === 'object' && result.animate;

            if (resultText && command !== 'clear') {
                const res = document.createElement("p");
                if (resultClass) res.classList.add(resultClass);
                res.style.marginLeft = "10px";
                
                output.appendChild(res);

                //  AADIDO: Si requiere animaci贸n (ej. cat README.txt), llamamos al efecto
                if (shouldAnimate) {
                    typeWriterEffect(res, resultText);
                } else {
                    res.textContent = resultText;
                }
            }

            output.scrollTop = output.scrollHeight;
        };

        input.addEventListener('keydown', (e) => {
            // Bloquear input si est谩 en medio de una animaci贸n de tecleo
            if (isTyping) {
                e.preventDefault();
                return;
            }

            if (e.key === "Enter") {
                e.preventDefault();

                const command = input.value.trim();
                if (command.length === 0) {
                    appendOutput('', ''); 
                    input.value = "";
                    return;
                }

                history.unshift(command);
                historyIndex = -1;

                const result = executeCommand(command);
                appendOutput(command, result);

                input.value = "";
            }
            
            if (e.key === "Tab") {
                e.preventDefault();
                const currentInput = input.value;
                const { completion, matches } = getCompletions(currentInput);

                if (matches.length === 1) {
                    input.value = completion;
                } else if (matches.length > 1) {
                    appendOutput(currentInput, matches.join("    "));
                }
            }

            if (e.key === "ArrowUp") {
                e.preventDefault();
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    input.value = history[historyIndex];
                }
            }

            if (e.key === "ArrowDown") {
                e.preventDefault();
                if (historyIndex > 0) {
                    historyIndex--;
                    input.value = history[historyIndex];
                } else {
                    historyIndex = -1;
                    input.value = "";
                }
            }
        });

        terminalWrapper.addEventListener("click", (e) => {
            const selection = window.getSelection();
            if (!selection || selection.toString().length === 0) {
                 if(!isTyping) input.focus(); // Solo enfoca si no est谩 escribiendo solo
            }
        });
        
        input.focus();
    });
</script>